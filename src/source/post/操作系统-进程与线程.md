---
title: 操作系统(一): 进程与线程
date: 2022-04-13 17:38
categories:
- Linux
tags:
- Linux
- 操作系统
- 技术
---

# 进程

**进程**是程序 (静态概念) 的一次运行 (动态概念)。每次运行需要操作系统为其分配必要资源 (在**内核空间**中的**内存标识符** **(mm_struct)**、**PCB** **(task_struct)** 等)，进程是系统**资源分配**和**调度**的**最小单位**。

Linux 中所有进程通过 **PCB** (进程控制块，Process Control Block，即 **task_struct**) 来多种组织关系。

PCB 是进程的唯一标识，其中包括：

- 进程描述信息：进程标识符、用户标识符
- 进程控制和管理信息：进程状态、进程优先级
- 资源分配清单：内存地址空间、虚拟地址空间、打开的文件、I/O 设备
- CPU 信息：CPU 中各个寄存器的值，保证进程切换后需要重启时能够从断点继续运行

PCB 使用**链表**组织，将具有相同状态的进程链在一起，形成各种队列。

Linux 根据 **ELF** **可执行文件**创建出**进程影像**，将代码部分拷贝至新进程虚存空间低地址部分 (code 部分)，然后将可执行文件中数据拷贝到高地址部分 (data 部分)

![内存模型中一个进程的影像](../static/images/os2.png)

`/proc/slabinfo` 中有 task_struct、mm_struct 的记录。

<!-- more -->

## 进程状态

在一个进程的活动期间要具备三种基本状态：**运行状态、就绪状态、阻塞状态**

- 运行状态：该时刻进程占用 CPU
- 就绪状态：可运行，但由于其他进程处于运行状态导致该进程处于停止运行状态
- 阻塞状态：正等待某事件发生，即使此时刻给予其 CPU 控制权，也无法运行
- 阻塞挂起状态：进程在硬盘，并等待某个事件发生
- 就绪挂起状态：进程在硬盘，只要进入内存，就会马上运行

>  为什么需要挂起状态？

如果系统内存在大量阻塞进程，则会消耗大量的物理内存，在虚拟内存管理的系统中，会把阻塞态的进程从物理内存换出硬盘，在需要运行时，再从物理内存换入物理内存。

挂起不一定是系统挂起的，也可以是

- sleep 函数挂起进程，使用定时器，到期唤醒进程。
- 用户使用 Ctrl+Z 挂起进程

![进程状态图](../static/images/os1.png)

## 进程间组织关系

### 亲缘关系

一个进程创建一个子进程就形成**父子关系**。多个进程则形成**兄弟关系**。

这些关系可以利用各自的 task_struct 中的 parent、children 和 sibling 成员（都是 list_head 结构体，用 prev 和 next 指针指向前驱和后继）组织这些关系。

![进程间亲缘关系](../static/images/os3.png)

在 Linux 中，通过 `pstree` 命令，我们可以看到全系统的进程树结构。

使用 `ps j` 也可以查看进程父子信息

### 会话、进程组、线程组及控制终端

Linux 下拥有多个**会话** (session)，每个会话包含多个**进程组** (process group)，每个进程组包含多个**进程**，每个进程构成一个**线程组**，一个线程组由进程内一个或多个**线程**组成。

- **会话**是用户登陆系统到退出前的全部活动，不同帐户的登录属于不同会话，而同一帐户的多次登录也构成不同的会话。
- 从登陆到结束前创建的所有进程都属于这次会话，第一个被创建的进程 (通常是 shell)称为会话的**领头进程** (session leader）
- 在 shell 上的一条命令所产生的所有进程形成一个进程组，每个进程组内第一个进程往往成为**领头进程** (process group leader)

## Linux 下进程控制

### 创建进程

创建进程的过程：

- 分配唯一进程标识符，并且申请新的空白 PCB
- 为进程分配资源
- 初始化 PCB
- 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行

#### fork()

`fork()` 函数的头文件是 `unistd.h`， 函数原形为 `int fork( void )`。

fork 函数被成功调用后会按照父进程的样子复制一个新的子进程，父进程 fork 函数结束时的返回值是子进程的 PID 编号，新的子进程 fork 函数返回的是 0，表示这是一个子进程。

#### exec()

`execve()` 函数第一个参数是想要变成的新的进程影像（可执行文件），第二个参数是命令行参数，第三个变量是环境变量。

`exec()` 直接将当前进程变成指定的进程。

### 撤销进程

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。

撤销进程的过程：

- 查找需要撤销进程的 PCB
- 如处于执行态，则立即停止，并且将 CPU 资源分配给其他进程
- 如有子进程，将其所有子进程终止
- 将资源都归还给父进程或操作系统
- 将其从 PCB 队列中删除

在 Linux 下，可以通过 `kill -PID` 命令杀死指定 PID 进程。

`killall` 用于杀死指定进程名的所有进程——它不是用 PID（例如 `killall httpd`）。

些信号可以通过 `kill –l` 或 `killall -l` 列出。其中 9 号信号时最强的信号——无条件终止进进程且不能被进程所忽略。

#### kill()

函数原型为 `int kill(pid_t pid, int sig)`，第一个参数是目标进程的 PID，第二个参数是发送的信号。

`kill()` 或 `raise()` 的信号取值为 SIGKILL 可用于杀死进程。

### 守护进程

## 孤儿进程和僵尸进程

**孤儿进程**：一个父进程退出，而他的子进程还在运行，这些进程将被 init 进程 (进程号为 1) 收养，并由 init 进程收集他们的状态，这就是孤儿进程。

**僵尸进程**：一个子进程在其父进程没有调用 `wait()` 或 `waitpid()` 的情况下退出，这个子进程就成为了僵尸进程。

子进程结束后大部分资源被**直接回收**，但是还是会在 PCB 中记录一下退出时的状态和信息，这些由**父进程回收**，僵尸进程将导致其资源无法回收，造成浪费。

# 线程

**线程** (thread) 是**CPU调度的最小单位**。同一个进程内多个线程可以共享代码段，数据段、打开的文件资源等，但一个进程拥有独立的**寄存器和栈**，可以确保线程控制流是相对独立的。

![多进程多线程并发的地址空间](../static/images/os4.png)

由 ELF-file-x 可执行程序创建的进程 P0，以及 ELF-file-y 可执行程序创建 P1 和 P2，其中 P2 共有两个线程。

线程在内存中也存在一个 task_struct 来保存自己的控制块。但没有 mm_struct，即一个进程的多个线程共享 mm_struct。

## 线程的实现

三种线程的实现方式：

- 用户线程：在用户空间实现的线程，由用户态的线程库来完成线程的管理
- 内核线程：在内核中实现的线程，是由内核管理的线程
- 轻量级线程：在内核中来支持用户线程

### 用户进程

用户线程基于用户态的线程管理库，**线程控制块** (TCB) 是库里面实现的，操作系统只能看见进程的 PCB，看不见 TCB。

用户线程的线程管理和调度由用户级线程库函数来完成线程的管理，**操作系统不直接参与**。

**用户线程模型**：多个用户线程对应同一个内核线程

用户线程**优点**：

- 用户线程切换由线程库函数来完成，无需用户态与内核态的切换
- TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统

用户线程**缺点**：

- 操作系统不参与用户线程调度，如果一个线程被阻塞，则这个进程中的其他用户线程也无法执行
- 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行
- 每个线程得到的时间片较少

### 内核线程

内核线程是由操作系统管理和调度的

**内核线程模型**：一个用户线程对应同一个内核线程

内核线程**优点**：

- 如果一个线程被阻塞，不会影响其他线程
- 每个线程得到的时间片较多

内核线程**缺点**：

- 由内核来维护线程的 TCB 和上下文
- 线程管理由系统调用完成，系统开销大

### 轻量级进程

**轻量级进程**是内核支持的用户线程，每个 LWP 和内核线程一对一映射。

## 创建线程

## 进程与线程的比较

- **进程**是**资源分配**的单位，**线程**是 **CPU 调度**的单位。
- 进程拥有独立的**资源空间**，而线程只有独立的**寄存器和栈**，其他共享
- 线程的**创建时间**比进程快，**终止时间**比进程快
- 同一个进程内的线程切换比进程切换快，线程具有相同地址空间
- 线程间通信效率高，不需要通过内核

# 进程间通信

## 管道

管道通信主要用于**单向通信**，实质上是一个由内核管理的一个缓冲区 (一边由进程写入，一边由进程独出)，如果缓冲区满了写管道的进程会被阻塞。

管道内部没有显示的格式和边界，要自行处理消息边界。

管道生命周期随着进程。

管道通信效率低，不适合进程频繁交换数据。

Linux 命令中使用 `|` 来连接两个命令时使用的就是**无名管道**。

shell 程序在处理 `ls | more` 时，首先调用 `pipe()` 系统调用，创建管道并返回一对文件描述符，然后调用两次 `fork()` 分别创建两个子进程（后面会替换成 `ls` 和 `more` 两个进程），此时两个子进程继承了 shell 的所打开的文件资源。接着关闭不需要的管道。外用户要关闭不使用的管道端口，否则可能会出现异常情况。

**对于无名管道，它的通信范围是存在父子关系的进程**。

**命名管道** (FIFO) 数据先进先出，可以在不相关的进程间使用。

通过 `mkfifo` 命令来创建命名管道：

```shell
mkfifo myPipe
```

我们可以往 myPipe 这个管道写入数据

```shell
echo "hello" > myPipe
```

可以读取这个管道里的数据

```shell
cat < myPipe
```

**对于命名管道，它可以在不相关的进程间也能相互通信**。

Linux 下可以用 `int mkfifo(const char * pathname, mode_t mode)` 来创建命名管道。

## 消息队列

**消息队列**是保存在内核中的**消息链表**。每个消息间有明显的格式和边界。

消息队列生命周期随着内核。

消息队列缺点：

- 通信不及时
- 附件大小有限制，Linux 内核中的 `MSGMAX`  和  `MSGMNB` 宏以字节为单位，分别定义一个消息最大长度和最大队列长度。
- 消息队列通信中，存在用户态和内核态的数据拷贝开销

在 Linux 中：

- 通过 `ftok()` 将外部 key 转换成内部 ID
- `msgget(key, IPC_CREAT|0660)` 打开或创建一个消息队列
- `msgsnd()` 发送数据
- `msgrcv()` 接受数据
- `msgctl()` 删除和修改访问模式

可以执行 `msgtool r` 删除指定的消息队列，用 `msgtool m` 修改该消息队列 的访问模式

## 共享内存

**共享内存**的机制，即拿出一块虚拟地址空间，映射到相同的物理内存。省去了消息队列中内核态与用户态之间的数据拷贝。但是如果是多线程操作，可能产生**竞态问题**。

在 Linux 中，使用 `shmget(IPC_PRIVATE, BUFSZ, 0666)` 来创建一个共享内存。

## 信号量

**信号量**是一个整形计数器，用于实现进程间的互斥与同步。

控制信号量的方式有两种**原子**操作

- P 操作：信号量减去 1，相减后如果信号量小于 0，则阻塞等待
- V 操作：信号量增加 1，相加后如果信号量小于等于 0，则当前存在被阻塞的进程，将唤醒这些进程

P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

信号初始化为 `1`，就代表着是**互斥信号量**，信号初始化为 `0`，就代表着是**同步信号量**。

Linux 同时支持 System V IPC 中的信号量集和 POSIX 信号量。

System V IPC 用于**进程**间通信，POSIX 用于**线程**间通信。

对于所有 System V 信号量函数，在它们的名字里面没有下划线（例如，有 `semget()` 而不是`sem_get()`），然而所有的的 POSIX 信号量函数都有一个下划线（例如，有 `sem_post()`而不是 `sempost()`）。

### POSXI 信号量

POSIX **无名信号量**适用于**线程**间通信，如果无名信号量要用于进程间同步，信号量要放在 共享内存中。

无名信号量使用 `sem_init()` 创建。

**有名信号量**由于可以通过标识来访问，可以同时用于**进程**间同步和**线程**间同步。

有名信号量的创建使用 `sem_open()` 完成。

通过 `sem_wait()` 来执行 V 操作，通过 `sem_getvalue()` 来查看信号量的值，通过 `sem_post()` 来执行 P 操作。通过 `sem_unlink()` 撤销信号量。

## 信号

**信号**是进程间通信机制中唯一的**异步通信机制**。

对信号的处理方式

- 默认方式
- 捕获信号
- 忽略信号

在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，通过 `kill -l` 可以查看

```shell
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示挂起该进程，但还未结束；

Linux 下可以通过 `kill` 命令的方式给进程发送信号。

## Socket

Socket 可以跨网络进程间通信。具体看博客其他网络相关文章。

# 死锁

# 进程调度算法

# 参考书籍及文章

1、小林 coding - 进程与线程
[https://xiaolincoding.com/os/4_process/process_base.html#进程](https://xiaolincoding.com/os/4_process/process_base.html#进程)

2、《操作系统之编程观察》 罗秋明