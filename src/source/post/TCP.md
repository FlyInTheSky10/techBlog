---
title: TCP 知识详解
date: 2022-03-06 21:38
categories:
- Linux
tags:
- Linux
- 计算机网络
- TCP
- 技术
---

# TCP 介绍

TCP提供了一种**面向连接的 (connection-oriented)、可靠**的**字节流服务**。术语“面向连接的”是指使用TCP的两个应用程序必须在它们可交换数据之前，通过相互联系来建立一个TCP连接。

当TCP接收到连接的另一端的数据时,它会发送一个**确认**。这个确认可能不会立即发送，而一般会延迟片刻。TCP使用的**ACK是累积**的，从某种意义来讲，一个指示字节号$N$的ACK暗示着所有直到$N$的字节(但不包含$N$)已经成功被接收了。这对于ACK丢失来说带来了一定的鲁棒性——如果一个ACK丢失，后续的ACK就足以确认前面的报文段了。

TCP给应用程序提供一种**双工服务**。这就是说数据可向两个方向流动，两个方向互相独立。因此，连接的每个端点必须对每个方向维持数据流的一个序列号。

每个TCP连接由一对**套接字或端点**（四元组，由客户机IP地址、客户机端口号、服务器IP地址以及服务器端口号组成）唯一地标识。

**序列号(Sequence Number)， seq**字段标识了TCP发送端到TCP接收端的数据流的一个字节,该字节代表着包含该序列号的报文段的数据中的第一个字节。TCP给每个字节赋予一个序列号。这个序列号是一个$32$位的无符号数,到达$2^{32}-1$后再循环回到0。**ACK**包含的值是该ACK(确认号)的发送方期待接收的下一个序列号。即最后被成功接收的数据字节的序列号加1。

当**建立一个新连接**时，从客户机发送至服务器的第一个报文段的SYN位字段被启用。 这样的报文段称为SYN报文段,或简单地称为**SYN**。然后序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，后续序列号和返回的ACK号也在这个方向上(回想一 下，连接都是双向的)。注意这个数字不是0和1，而是另一个数字，经常是随机选择的，称为**初始序列号(Initial SequenceNumber, ISN)**。

SYN位字段会消耗一个序列号，消耗一个序列号也意味着使用重传进行**可靠传输**。不消耗序列号的ACK则不是。

# TCP 三次握手建立链接

![](../static/images/tcp1.png)

它们也常称作**三次握手** 。三次握手的目的不仅在于让通信双方了解一个连接正在建立,还在于利用数据包的选项来承载特殊的信息，**交换初始序列号(Initial Sequence Number, ISN)**。客户端和服务端的初始序列号是**随机且不同**的。<!-- more -->

> 第三次握手是可以携带数据的，前两次握手是不可以携带数据的。

(RFC793) 带有SYN标志的过程包是不可以携带数据的，也就是说三次握手的前两次是不可以携带数据的（逻辑上看，连接还没建立，携带数据好像也有点说不过去）。

> 为什么是三次握手？不是两次、四次？

**1、避免历史连接**

(RFC793) The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.

三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

客户端连续发送多次 `SYN` 建立连接的报文，在网络拥堵等情况下：

- 一个「旧 `SYN` 报文」比「最新的 `SYN` 」 报文早到达了服务端；
- 那么此时服务端就会回一个`SYN + ACK`报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送`RST`报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是`RST`报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是`ACK`报文，通信双方就会成功建立连接

**2、同步双方初始序列号**

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以**去除重复**的数据；
- 接收方可以根据数据包的序列号**按序接收**；
- 可以标识发送出去的数据包中， **哪些是已经被对方收到的**

当客户端发送携带「初始序列号」的`SYN`报文的时候，需要服务端回一个`ACK`应答报文，表示客户端的 `SYN` 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。

**3、避免资源浪费**

如果只有「两次握手」，当客户端的`SYN`请求连接在网络中阻塞，客户端没有接收到`ACK`报文，就会重新发送`SYN`，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的`ACK`确认信号，**所以每收到一个`SYN`就只能先主动建立一个连接。**

如果客户端的`SYN`阻塞了，重复发送多次`SYN`报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

> 第一次握手丢失了，会发生什么？

如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发**「超时重传」机制**，重传 SYN 报文。

在 Linux 里，客户端的 SYN 报文最大重传次数由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。**每次超时的时间是上一次的 2 倍**。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

所以，总耗时是 1+2+4+8+16+32=63 秒。

> 第二次握手丢失了，会发生什么？

第二次握手的 `SYN-ACK` 报文有两个目的 ：

- 第二次握手里的 ACK， 是对第一次握手的确认报文；
- 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文

如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。

> 第三次握手丢失了，会发生什么？

服务端收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

> 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

- `MTU`：一个网络包的最大长度，以太网中一般为`1500`字节；
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度

**那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传**。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

> 什么是 SYN 攻击？如何避免 SYN 攻击？

假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，久而久之就会**占满服务端的半连接队列**，使得服务器不能为正常用户服务。

SYN 攻击成立的关键在于服务器资源是有限的，而**服务器收到请求会分配资源**。

避免方法：

1、修改 Linux 内核参数

当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。

- 控制该队列的最大值：`net.core.netdev_max_backlog`

- SYN_RCVD 状态连接的最大个数：`net.ipv4.tcp_max_syn_backlog`
- 超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：`net.ipv4.tcp_abort_on_overflow`

2、tcp_syncookies

`SYN Cookie`技术可以让服务器在收到客户端的`SYN`报文时，**不分配资源保存客户端信息**，而是将这些信息保存在`SYN+ACK`的初始序号和时间戳中。对正常的连接，这些信息会随着`ACK`报文被带回来。

# TCP 四次挥手关闭链接

## TCP 半关闭

![](../static/images/tcp2.png)

半关闭处于 TIME_WAIT 状态，**主动关闭连接的，才有 TIME_WAIT 状态。**

服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。

> 第一次挥手丢失了，会发生什么？

如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，直接进入到 `close` 状态。

> 第二次挥手丢失了，会发生什么？

所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。

> 第三次挥手丢失了，会发生什么？

如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retrie`s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

> 第四次挥手丢失了，会发生什么？

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。

# TCP 状态

![](../static/images/tcp3.png)

普通的客户端状态转移用深黑的实线箭头表示，而普通的服务器状态转换用虚线箭头表示。

将FIN_WAIT_1 、FIN_WAIT_2以及TIME_WAIT状态用一个方框括起来(至少是部分被括起来),称作**“主动关闭”** 。它们表示当本地应用程序发起一个关闭请求时会进入的状态集合。另外两个状态(CLOSE_WAIT与LAST_ACK)被一个虚线框括起来，并标记为**“被动关闭” **

![](../static/images/tcp4.png)

**TIME_WAIT状态**也称为2MSL等待状态。在该状态中，TCP将会等待两倍于最大段生存期(Maximum Segment Lifetime, MSL)的时间，有时也被称作加倍等待。每个实现都必须为最大段生存期选择一个数值。

在**TIME_WAIT_2状态**，某TCP通信端已发送一个FIN并已得到另一端的确认。除非出现半关闭的情况,否则该TCP端将会等待另一端的应用程序识别出自己已接收到一个文件末尾的通知并关闭这一端引起发送FIN的连接。只有当应用程序完成了这一关闭操作(它的 FIN已经被接收), 正在关闭的TCP连接才会从**FIN_WAIT_2**状态转移至**TIME_WAIT**状态。 这意味着连接的一端能够依然永远保持这种状态。另一端也会依然处于**CLOSE_WAIT**状态, 并且能永远维持这一状态直到应用程序决定宣布它的关闭。

如果负责主动关闭的应用程序执行的是一个完全关闭操作，而不是用一个半关闭来指明它还期望接收数据，那么就会设置一个计时器来避免接进入FIN_WAIT_2这一无限等待状。



# 实验

三次握手：

![](../static/images/tcp_ex1.png)

四次挥手：

![](../static/images/tcp_ex2.png)
