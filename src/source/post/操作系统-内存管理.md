---
title: 操作系统(二): 内存管理
date: 2022-04-15 17:38
categories:
- Linux
tags:
- Linux
- 操作系统
- 技术
---

# 内存管理

## 虚拟内存

操作系统会提供一种机制，使**不同进程**的**虚拟地址**和不同的**内存物理地址**相映射。

- 在程序中使用的内存地址是**虚拟内存地址**
- 在硬盘里的内存地址是**物理内存地址**

进程持有的虚拟地址会使用 CPU 芯片中的**内存管理单元** (MMU) 来找到对应的物理内存地址。

## 内存分段

分段机制下的虚拟地址分为**段选择子**和**段内偏移量**。

- 段选择子包含**段号**，是**段表**的索引，段表里保存了**段的基地址**、**段的界限**和特权等级
- **段内偏移量**包含于区间 [0, 段界限]，段基地址加上段内偏移量则可以得到物理内存地址

虚拟地址通过**段表**与物理地址进行映射。

![内存分段](../static/images/os5.png)

分段**缺点**：

- 内存存在碎片
- 内存交换效率低

<!-- more -->

## 内存分页

**分页**把整个虚拟和物理内存空间切成一段段**固定**的大小，称为**页**。

在 Linux 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射。

当进程访问的页表在内存找不到时，会产生一个**缺页异常**，进入系统态分配物理内存，更新进程页表，最后再返回用户态，恢复进程运行。

**采用了分页，释放的内存都是以页为单位释放的，所以不会有内存碎片的问题。**

如果内存空间不够，操作系统会把最近没被使用的页释放出内存，写到硬盘，称为**换出**，需要的时候加载回来，称为**换入**。

分页方式使我们可以在加载程序时不需要一次性都把程序加载到物理内存，可以映射之后，用到该数据页再将该数据页换入到物理内存。

分页机制下的虚拟地址分为**页号**和**页内偏移**。页号是**页表**的索引，页表包含了**每页的物理内存基地址**。

![内存分页](../static/images/os6.png)

**分页**缺点：

页表过大。

在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（$2^{12}$），那么就需要大约 100 万 （$2^{20}$） 个页，每个**页表项**需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。

每个进程都有自己的虚拟地址空间，也就说都有自己的页表。

那么，100 个进程的话，就需要 400MB 的内存来存储页表。

### 多级页表

![内存分页](../static/images/os7.png)

**如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**。

## 段页式内存管理

方式：

- 先将内存分段
- 再将分好的段分页

地址结构由**段号、段内页号和页内位移**三部分组成。

![内存分页](../static/images/os8.png)

# Linux 内存管理

Linux 内存中每个段都是从 0 地址开始 4GB 大小的虚拟空间 (32位系统)，**也就是所有段的起始位置相同。**Linux 中的代码面对的都是虚拟地址，分段用来屏蔽处理器中的逻辑地址概念，用于访问控制和内存保护。

Linux 虚拟地址内部分为内核空间和用户空间。不同位数的系统，地址空间的范围也不同。

![Linux 虚拟地址](../static/images/os9.png)

内核空间与用户空间的区别

- 进程在用户态时，只能访问用户空间内存
- 进入内核态后，才可以访问内核空间的内存
